# Тема проекта -  Vkontakte
## *MVP*  
 NewsFeed - приложение, в котором можно подписываться на других людей, смотреть их посты, и выкладывать свои.
### Целевая аудитория:
* [77% от всей мобильной аудитории в России – первое место.](https://vk.com/@cerebro_vk-polzovateli-socsetei-v-rossii-statistika-i-portrety-auditori)
* 73 миллионов активных пользователей в месяц.
* [42 млн человек в день.](https://ppc.world/articles/auditoriya-shesti-krupneyshih-socsetey-v-rossii-v-2020-godu-izuchaem-insayty/)
* Россиская Федерация
### Рассчет нагрузки
1) #### *Рассчет нагрузки на создание постов:*
    По данным статистики за [май 2017](https://vk.com/@cerebro_vk-polzovateli-socsetei-v-rossii-statistika-i-portrety-auditori):
    - 25 721 668 - число авторов, сделавших пост за месяц
    - 310 795 150 - число постов в месяц 
    
    Зная число постов в месяц, можем посчитать сколько постов в среднем делается за один день:

       310 795 150 / 31 = 10 025 650 постов/день


Теперь посчитаем число запросов в секунду, мы знаем что наибольший пик активности в Вконтакте приходится на обед с 11 до 13,
и вечером с 17 до 23 => Итого: [8 часов в день](https://postium.ru/luchshee-vremya-dlya-publikacii-postov-v-instagram-vk/)

Тогда для получения числа постов в секунду:


    10 025 650 / (8 * 3600) ~ 348 запросов/c


2) #### *Рассчет нагрузки на создание ленты:*
    Пусть каждый пользователь делает по 7 запросов в день на создание ленты, зная число пользователей
в среднем в день (42 млн) и наибольший пик активности равный 8 часам, получим:
   

      42 * 10^6 * 7 / (8 * 3600) = 10 208 запросов/c


### Итоги по РПС сервиса:
*  Создание постов ~ 350 запросов / секунду (на запись)
* Составление ленты ~ 10 000 запросов / секунду (на чтение)


### Логичекая схема Базы Данных
Сущности в моем проекте:
1) Пользователь
2) Пост
3) Подписки
4) Лайки
5) Темы
6) Рекомендации
7) Комментарии

Каждая из этих моделей необходима для формирования ленты для пользователя, если немного углубиться, то подразумевается две ленты
одна формируется исходя из подписок пользователя, вторая из рекомендаций. Также необходимо пояснить что такое темы, темы - это механизм, 
который используется для формирования рекомендаций, с их помощью мы будем давать пользователю только тот контент, который ему интересен. (пример тем: спорт, автомобили и т.д)
Рекомендации намеренно денормализованы так, чтобы для каждого пользователя хранить рекомендуемые ему посты.
Остальные модели хранят исключительно id, без полных сущностей.

![Логическая схема БД](https://github.com/Amaterasy17/HighLoad-courseWork/raw/main/images/logical_scheme_db.png)

### Физическая схема Базы Данных
В рассчете нагрузки показано, что у нас нет большой нагрузки на запись, поэтому
для хранения большинства данных будем использовать реляционную СУБД PostgreSql, она обладает высокой надежностью и ее будет достаточно для создания новых в ней данных, таких как посты, пользователи, лайки и комментарии. В ее схему будут входит следующие модели:
пользователь, лайк, подписки, комментарии, темы, пост, промежуточные таблицы для отношения М-М.
Для ускорения записи применим шардирование.

Также важно учесть, что нам необходимо каким-то образом хранить метаданные постов, то есть фотографии, видео или музыку.
Для этого было бы оптимально использовать какое либо облачное хранилище MCS (Mail.ru Cloud Solutions)
Оно отлично подойдет благодаря высокой степени надежности хранения, а также данное хранилище обеспечит высокую скорость трафика в 1Gb/s.
Самые просматриваемые метаданные постов можно будет хранить в MCS на виртуалке с SSD, для еще более быстрого доступа.

Также у нас будет большая нагрузка на чтение, следовательно оптимально будет использовать
для чтения нереляционную in-memory БД, такую, например, Redis. Она быстрая и доступ к данным внутри нее
будет практически равен доступу к оперативной памяти. Поэтому список рекоммендаций будем хранить в данной нереляционной СУБД.
Рекомендации будут представлять собой id пользователя, и список рекомендуемых ему постов, которые будут определяться по темам, интересных пользователю.

Также меньшая часть нагрузки на чтение будет распределятья на PostgreSql
в случае получения человеком постов по подпискам(иными словами получение постов друзей).
Вы можете задаться вопросом почему меньшая часть? Как правило, у большинства людей не так много подписок и выложенных постов суммарно, поэтому не будет
сложности в формировании постов от друзей, потому что их обычно не так много.
А для увелечения отказоустойчивости и ускорения чтения, будем использовать реплики. Пользователь, который загружает новые посты и не заметит
отсутствия постов, которые были созданы только что.

Для хранений сессий пользователей будет оптимальным использовать нереляционную in-memory СУБД, так что и для данной задачи нам 
подойдет Redis.


### Выбор технологий
#### *Frontend* 
Здесь мы будем использовать следующее сочетание: *HTML* + *SCSS* + *TypeScript*.
Используем TypeScript так как он статически типизируемый и обладает большим спектром возможностей, чем JS,
потому что является его надстройкой. Важно выбрать библиотеку для фронта, на самом деле все зависит от команды разработки,
от того с чем они знакомы, но для примера возьмем одну из популярных библиотек такую как React. Для сборки бандлов и поддержки
старых браузеров будем исползовать webpack и babel. Также можно использовать SSR (Server Side Rendering) на Next.js
для продвижения сайта вверх в списке
поиска и улучшения восприятия пользователем сайта, благодаря быстрой загрузке стартовой страницы.

#### *Backend*
Здесь будем использовать микросервисную архитектуру, которая позволит легко масштабироваться, а также
контролировать нагрузку на сервисы. Основным языком в микросервисах будет *Golang*, так как
он поддерживает параллелизм из коробки и является очень быстрым, производительным. Обязательно
будет микросервис рекомендаций, который будет написан на *C++*, используем его, так как нам важна максимальная скорость
 и производительность. Данный микросервис на плюсах будет ходить в реплики postgreSQL для формирования рекомендаций
пользователям, результат работы будет складывать в Redis. Микросервисы будут общаться между собой по gRPC.

#### *Mobile*
Здесь можно использовать *Kotlin* для Android, *Swift* для IOS.

### Схема проекта


 




